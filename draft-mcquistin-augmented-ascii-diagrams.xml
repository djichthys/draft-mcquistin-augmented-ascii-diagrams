<?xml version='1.0' encoding='US-ASCII'?>
<rfc ipr='trust200902' submissionType='IETF' category='info' docName="draft-mcquistin-augmented-ascii-diagrams-00">
    <front>
        <title abbrev='Augmented ASCII Diagrams'>
            Fully Specifying Protocol Parsing with Augmented ASCII Diagrams
        </title>
        <seriesInfo name='Internet-Draft' value='draft-mcquistin-augmented-ascii-diagrams-00' status="informational" />

        <author fullname='Stephen McQuistin' initials='S.' surname='McQuistin'>
            <organization>University of Glasgow</organization>
            <address>
                <postal>
                    <street>School of Computing Science</street>
                    <city>Glasgow</city>
                    <code>G12 8QQ</code>
                    <country>UK</country>
                </postal>
                <email>sm@smcquistin.uk</email>
            </address>
        </author>

        <author fullname='Colin Perkins' initials='C.' surname='Perkins'>
            <organization>University of Glasgow</organization>
            <address>
                <postal>
                    <street>School of Computing Science</street>
                    <city>Glasgow</city>
                    <code>G12 8QQ</code>
                    <country>UK</country>
                </postal>
                <email>csp@csperkins.org</email>
            </address>
        </author>

        <date year='2019'/>

        <abstract>
            <t>
                This document describes a format for fully specifying the process by which
                a protocol can be parsed. This format combines a consistent ASCII packet
                diagram format with the use of structured text, maintaining human
                readability while enabling support for machine parsing. This document is
                itself an example of how this format can be used, and it can be parsed
                using code provided.
            </t>
        </abstract>
    </front>

    <middle>
        <section anchor='intro'>
            <name>Introduction</name>
            <t>
                ASCII packet header diagrams have become the de-facto format for
                describing the syntax of binary protocols. In otherwise largely textual
                documents, they allow for the visualisation of packet formats, reducing
                human error, and aiding in the implementation of parser for the protocols
                that they specify. Given their widespread use, and relatively structured
                form, ASCII packet header diagrams provide a good base from which to
                develop a format that enables the automatic generation of parser code from
                protocol standards documents.
            </t>
            <t>
                To support this new function, there are two broad issues with the existing
                ASCII packet header format that must be addressed. Firstly, their use,
                while sufficiently consistent for human readability, contains enough
                variation to make machine parsing difficult: different documents tend to
                use subtly different formats. Secondly, ASCII packet header diagrams alone
                do not fully capture the parsing process for protocols, requiring
                supplementary text. To support machine parsing, this supplementary text
                must be structured.
            </t>
            <t>
                This document describes a consistent ASCII packet header format and 
                accompanying structured text constructs that allow for the parsing process
                of a protocol to be fully specified. This provides support for the
                automatic generation of parser code. Broad design principles, that seek
                to maintain the primacy of human readability and flexibility in
                authorship, are described, before the format itself is given.
            </t>
            <t>
                This document is itself an example of the approach that it describes, with
                code provided that can parse the ASCII packet diagrams and structured
                text that this document contains.
            </t> 
        </section>

        <section anchor='background'>
            <name>Background</name>
            <t>
                This section begins by considering how ASCII packet header diagrams are
                used in existing documents. This exposes the limitations that the current
                usage has in terms of machine-readability, guiding the design of the
                format that this document proposes.
            </t>
            <t>
                While this document focuses on the machine-readability of packet header
                diagrams, this section also discusses the use of other, structured or formal
                languages within IETF languages. Considering how and why these languages
                are used provides an instructive contrast to the relatively incremental
                approach proposed here.
            </t>
            
            <section anchor='background:ascii'>
                <name>Limitations of current use of ASCII packet diagrams</name>
                <t>
                    ASCII packet header diagrams are commonplace in the IETF standards
                    documents for binary protocols. While there is no standard for how
                    these diagrams should be formatted, they have a broadly similar structure,
                    where the layout of a PDU or structure is given in an ASCII diagram,
                    and a description list of the fields that it contains are given
                    immediately below. An example of this format is given in
                    <xref target="quic-reset-stream"/>.
                </t>
                <figure anchor="quic-reset-stream">
                    <name>QUIC's RESET_STREAM frame format (from <xref target="QUIC-TRANSPORT"/>)</name>
                    <artwork>
   The RESET_STREAM frame is as follows:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Application Error Code (16)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Final Size (i)                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   RESET_STREAM frames contain the following fields:

   Stream ID:  A variable-length integer encoding of the Stream ID of
      the stream being terminated.

   Application Protocol Error Code:  A 16-bit application protocol error
      code (see Section 20.1) which indicates why the stream is being
      closed.

   Final Size:  A variable-length integer indicating the final size of
      the stream by the RESET_STREAM sender, in unit of bytes.
                    </artwork>
                </figure>
                <t>
                    However, these diagrams, and their accompanying descriptions, are
                    formatted for human readers rather than for machine parsing. As a
                    result, while there is broad consistency in how ASCII packet diagrams
                    are formatted, there are a number of limitations that are prohibitive
                    for machine parsing:
                </t>
                <dl>
                    <dt>
                        Inconsistent syntax:
                    </dt>
                    <dd>
                        There are two classes of consistency that are required for
                        parsability: internal consistency, within a document or diagram,
                        and external consistency, across all documents. Given that ASCII
                        packet diagrams are formatted for human readers, rather than for
                        machine parsing, there is sufficient variability in how they are
                        formatted that parsing is difficult.
                        
                        <figure anchor="dhcpv6-relaysrcopt">
                            <name>DHCPv6's Relay Source Port Option (from <xref target="RFC8357"/>)</name>
                            <artwork>
   The format of the "Relay Source Port Option" is shown below:

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    OPTION_RELAY_PORT    |         Option-Len                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Downstream Source Port     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Where:

   Option-Code:  OPTION_RELAY_PORT. 16-bit value, 135.

   Option-Len:  16-bit value to be set to 2.

   Downstream Source Port:  16-bit value.  To be set by the IPv6 relay
      either to the downstream relay agent's UDP source port used for
      the UDP packet, or to zero if only the local relay agent uses the
      non-DHCP UDP port (not 547).
                            </artwork>
                        </figure>
                        
                        <xref target="quic-reset-stream"/> gives an example of internal
                        inconsistency. Here, the ASCII diagram shows a field labelled
                        "Application Error Code", while the accompanying description lists
                        the field as "Application Protocol Error Code". The use of an
                        abbreviated name is suitable for human readers, but makes parsing
                        the structure difficult for machines.
                        <xref target="dhcpv6-relaysrcopt"/> gives a further example, where
                        the description lists a field "Option-Code" that does not appear
                        in the ASCII diagram.
                        
                        Comparing <xref target="quic-reset-stream"/> with
                        <xref target="dhcpv6-relaysrcopt"/> exposes external
                        inconsistency across documents. While the ASCII diagrams
                        themselves are broadly similar, the text surrounding the diagrams
                        is formatted differently. If machine parsing is to be made
                        possible, then this text must be structured consistently.
                    </dd>
                
                    <dt>
                        Ambiguous constraints:
                    </dt>
                    <dd>
                        The constraints that are enforced on a particular field are often
                        described ambiguously, or in a way that cannot be parsed easily.
                        In <xref target="dhcpv6-relaysrcopt"/>, each of the three fields
                        in the structure is constrained. The first two fields
                        ("Option-Code" and "Option-Len") are to be set to constant values
                        (note the inconsistency in how these constraints are expressed in
                        the description). However, the third field ("Downstream Source
                        Port") can take a value from a constrained set. This constraint
                        is expressed in prose that can easily be parsed by humans, but not
                        by machines.
                    </dd>                
                    <dt>
                        Poor linking between sub-structures:
                    </dt>
                    <dd>
                        Protocol data units and other structures are often comprised of
                        sub-structures that are defined elsewhere, either in the same
                        document, or within another document. Chaining these structures
                        together is essential for machine parsing: the parsing process for
                        a protocol data unit is only fully expressed if all elements can
                        be parsed.
                        
                        <xref target="quic-reset-stream"/> highlights the difficulty that
                        machine parsers have in chaining structures together. Two fields
                        ("Stream ID" and "Final Size") are described as being encoded as
                        variable-length integers; this is a structure described elsewhere
                        in the same document. Structured text is required both alongside
                        the definition of the containing structure and with the definition
                        of the sub-structure, to allow a parser to link the two together.
                    </dd>
                </dl>
            </section>
            
            <section anchor='background:others'>
                <name>Formal languages in standards documents</name>
                
                <t>
                    A small proportion of IETF standards documents contain
                    structured and formal languages, including ABNF, ASN.1, C, CBOR, JSON,
                    the TLS presentation language, YANG models, and XML. While this broad
                    range of languages may be problematic for the development of tooling
                    to parse specifications, these, and other, languages serve a range of
                    different use cases. ABNF, for example, is typically used to specify
                    text protocols, while ASN.1 is used to specify the data structure
                    serialisation. In summary, different languages serve different
                    purposes. This document specifies a structure language for specifying
                    the parsing of binary protocol data units.
                </t>
                <t>
                    [todo: refs]
                </t>
                <t>
                    [todo: might be better to flip "Background" and "Design Principles".
                     The background would then be able to refer to the design principles,
                     and how they relate to the current use of ASCII packet diagrams and
                     other languages.]
                </t>
            </section>
        </section>

        <section anchor='designprinciples'>
            <name>Design Principles</name>
            <t>
                The use of structures that are designed to support machine readability
                may potentially interfere with the existing ways in which standardisation
                documents are used and authored. To the extent that these existing uses
                are more important than machine readability, such interference must be
                limited.
            </t>
            <t>
                In this section, the broad design principles that underpin the structures
                described by this document are given. However, these principles apply more
                generally to any approach that introduces structured and formal languages
                into standards documents.
            </t>
            <t>
                It should be noted that these are design principles: they expose the
                trade-offs that are inherent within any given approach. Violating these
                principles is sometimes necessary and beneficial, and this document sets
                out the potential consequences of doing so.
            </t>
            <t>
                The central tenet that underpins these design principles is a recognition
                that the standardisation process is not broken, and so does not need to be
                fixed. Failure to recognise this will likely lead to approaches that are
                incompatible with the standards process, or that will see limited
                adoption. However, the standards process can be improved with appropriate
                approaches, as guided by the following broad design principles:
            </t>
            <t>
                [todo: this list is currently unordered. It should probably remain
                 unordered, but it might be worth highlighting this in the text.]
            </t>
            <dl>
                <dt>
                    Most readers are human:
                </dt>
                <dd>
                    <t>
                        Primarily, standards documents should be written for people, who
                        require text and diagrams that they can parse, Structures that
                        cannot be easily parsed by people should be avoided, and if
                        included, should be clearly delineated from human-readable
                        content.
                    </t>
                    <t>
                        Any approach that shifts this balance -- that is, that primarily
                        targets machine readers -- is likely to be disruptive to the
                        standardisation process, which relies upon discussion centered
                        upon documents written in prose.
                    </t>
                </dd>

                <dt>
                    Authorship tools are diverse:
                </dt>
                <dd>
                    <t>
                        Authorship is a distributed process that involves a diverse set of
                        tools and workflows. The introduction of machine-readable
                        structures should limit the extent to which specific tools are
                        required to produce standards documents, such that existing
                        workflows can be maintained. This does not preclude the
                        development of optional, supplementary tools that aid in the
                        authoring machine-readable structures.
                    </t>
                    <t>
                        The immediate impact of requiring specific tooling is that
                        adoption is likely to be limited. A long-term impact might be that
                        authors whose workflows are incompatible might be alienated from
                        the process.
                    </t>
                    <t>
                        [todo: this last point feels weak.]
                    </t>
                </dd>

                <dt>
                    Canonical specifications:
                </dt>
                <dd>
                    <t>
                        As far as possible, machine-readable structures should not
                        introduce an additional specification of the protocol within the
                        same document. Such structures should form part of a canonical
                        specification of the protocol. The inclusion of supplementary
                        machine-readable structures creates the potential for divergent
                        specifications.
                    </t>
                    <t>
                        As an example, code that describes how a protocol should be parsed
                        may be provided as an appendix within a standards document. This
                        code provides a specification of the protocol that is separate to
                        that given in the main body of the document. This introduces the
                        potential for the code to specify behaviour that the text-based
                        specification does not, and vice-versa.
                    </t>
                    <t>
                        Ultimately, where supplementary code is given, the definition
                        given in the prose specification takes precedence. As a result,
                        any bugs in the code are likely to diminish the usefulness of this
                        part of the document.
                    </t>
                </dd>

                <dt>
                    Expressiveness:
                </dt>
                <dd>
                    <t>
                        Any approach should be expressive enough to capture the syntax
                        and parsing process for the majority of binary protocols. If a
                        given language is not sufficiently expressive, then adoption is
                        likely to be limited. At the limits of what can be expressed by
                        the language, authors are likely to revert to defining the
                        protocol in prose: this undermines the broad goal of using
                        structured and formal languages.
                    </t>
                </dd>
                
                <dt>
                    Minimise required change:
                </dt>
                <dd>
                    <t>
                        Any approach should require as few changes as possible to the way
                        documents are formatted, authored, and published. Forcing adoption
                        of a particular structured or formal language is incompatible with
                        the IETF's standardisation process: there are very few components
                        of standards documents that are non-optional.
                    </t>
                </dd>
            </dl>
        </section>

        <section anchor='augmentedascii'>
            <name>Augmented ASCII Packet Header Diagrams</name>
            <t>
                The design principles described in <xref target="designprinciples"/> can
                largely be met by the existing uses of ASCII packet header diagrams. These
                diagrams aid human readability, do not require new or specialised
                authorship tools, do not split the specification into multiple parts,
                can express most binary protocol features, and require no changes to the
                existing publication processes.
            </t>
            <t>
                However, as discussed in <xref target="background:ascii"/> there are
                limitations to how ASCII diagrams are used that must be addressed if they
                are to be parsed by machine. In this section, an augmented ASCII packet
                header diagram format is described.
            </t>
            <t>
                The format is described by example. This is appropriate, given the visual
                nature of the language. Further, these examples can be parsed using
                provided tools. A formal specification of the format is given in
                <xref target="ABNF"/>.
            </t>
            <t>
                In the format, each protocol data unit is described in its own section.
                This enables cross-referencing between data units using section numbering.
                In this specification-by-example, each element of the format will be
                described as part of a separate PDU.
            </t>
        
            <section anchor='ascii:simple'>
                <name>Fixed-width Field Format</name>
                <t>
                    A Fixed-width Field Format packet is formatted as follows:
                    <artwork>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |F2 |                         Field30                           |   
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                           Field64                             +       
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +            Field48            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               | 
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Field8    |
      +-+-+-+-+-+-+-+-+
                    </artwork>
                    where:
                    <dl>
                        <dt>
                            Field2 (F2): 2 bits
                        </dt>
                        <dd>
                            This is a short field, and the diagram cannot show its full
                            label. A short label (SF) is used in the diagram, and this
                            short label is provided, in brackets, after the full label
                            in the description list. The field's width -- 2 bits -- 
                            given in the label of the description list, separated from
                            the field's label by a colon.
                        </dd>
                        <dt>
                            Field30: 30 bits
                        </dt>
                        <dd>
                            This is a longer field whose full label can be shown in the
                            diagram. The field aligns with the 32-bit row boundary.
                        </dd>
                        <dt>
                            Field64: 8 bytes
                        </dt>
                        <dd>
                            This is a field that spans multiple rows, and ends on a 32-bit
                            boundary. As shown, field widths can be given in bytes as
                            appropriate.
                        </dd>
                        <dt>
                            Field48: 48 bits
                        </dt>
                        <dd>
                            This is longer, multi-row field, that does not end on a 32-bit
                            boundary. 
                        </dd>
                        <dt>
                            Field8: 1 byte
                        </dt>
                        <dd>
                            This field has been drawn on the next line, where it would
                            have fit on the previous line. Where possible, the formatting
                            of the diagram should be flexible to meet the needs of human
                            readers.
                        </dd>
                    </dl>
                </t>
            </section>
            
            <section anchor='ascii:variable'>
                <name>Variable-width Field Format</name>
                <t>
                    A Variable-width Field Format packet is formatted as follows:
                    <artwork>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Field8    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      FieldVar - single row                  ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      ~                      FieldVar - multi-row                     ~       
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      :             FieldVar - multi-row, boundary aligned            :       
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
                    </artwork>
                    where:
                    <dl>
                        <dt>
                            Field8 (F): 8 bits
                        </dt>
                        <dd>
                            This is a fixed-width field, as described previously.
                        </dd>
                        <dt>
                            FieldVar - single row: 2^F bits
                        </dt>
                        <dd>
                            This is a variable-length field, whose length is defined by
                            the value of the field with short label F (Field8). Constraint
                            expressions can be used in place of constant values: the
                            grammar for the expression language is defined in
                            <xref target="ABNF"/>. Where fields labels are used in a
                            constraint, the field being referred to must have been
                            defined before its label is used.
                            
                            Short variable-length fields are indicated by "..." instead of
                            a pipe at the end of the row.
                        </dd>
                        <dt>
                            FieldVar - multi-row: 2^F bits
                        </dt>
                        <dd>
                            This is a multi-row variable-length field, again constrained
                            by the value of field F. Instead of the "..." notation, "~" is
                            used to indicate that the field is variable-length. The use
                            of "~" instead of "..." indicates the field is likely to be
                            a longer, multi-row field. However, semantically, there is no
                            difference: these different notations are for the benefit of
                            human readers.
                        </dd>
                        <dt>
                            FieldVar - multi-row, boundary aligned:
                        </dt>
                        <dd>
                            This is a variable-width field whose length is implied by the
                            lengths of the other fields. At parsing time, the length of
                            the PDU is known, and this can be used to determine the length
                            of fields whose length is undefined. Each PDU can only leave
                            a single field's length undefined: all other fields must be
                            fixed-length, or have their widths constrained.
                            
                            In addition, ":" notation is used to indicate, in contrast
                            to the "~" notation, that the field width will align with a
                            32-bit boundary. Again, this notation is for the benefit of
                            human readers: there is no semantic difference. Any hard
                            constraints must be expressed using the constraint grammar in
                            the description list.
                        </dd>
                    </dl>
                </t>
            </section>
            
            <section anchor='ascii:xref'>
                <name>Cross-referencing and Sequences Format</name>
                <t>
                    A Variable-width Field Format packet is formatted as follows:
                    <artwork>
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Field8    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                                                               +       
      |                                                               |
      +                       FieldFixedXRef                          +       
      |                                                               |
      +                                                               +
      |                                                               |
      +                                               +-+-+-+-+-+-+-+-+
      |                                               |               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               ~
      |                                                               |
      ~                         FieldVarXref                          ~
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
      |                                                               |
      +                                                               +       
      |                                                               |
      +                       [SeqFieldFixedXRef]                     +       
      |                                                               |
      +                                                               +
      |                                                               |
      +                                               +-+-+-+-+-+-+-+-+
      |                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                    </artwork>
                    where:
                    <dl>
                        <dt>
                            Field8 (F): 8 bits
                        </dt>
                        <dd>
                            This is a fixed-width field, as described previously.
                        </dd>
                        <dt>
                            FieldFixedXRef: 1 Fixed-width Field Format
                        </dt>
                        <dd>
                            This is a field whose structure is a previously defined PDU
                            format. To indicate this, the width of the field is given in
                            units of the cross-referenced structure (here, Fixed-width
                            Field Format).
                        </dd>
                        <dt>
                            FieldVarXref: 1 Variable-width Field Format
                        </dt>
                        <dd>
                            This field references a variable-width structure. It can be
                            drawn to any width as appropriate, but must use a
                            variable-width notation. Where multiple variable-width field
                            format structures are referenced, the requirement that only
                            one field's length can be unspecified applies to the enclosing
                            structure.
                        </dd>
                        <dt>
                            SeqFieldFixedXRef: 2 Fixed-width Field Format
                        </dt>
                        <dd>
                            Where a field is comprised of a sequence of previously defined
                            structures, square brackets can be used to indicate this in
                            the diagram. The length of the sequence can be defined using
                            the constraint expression grammar as described earlier.
                        </dd>
                    </dl>
                </t>
            </section>
        </section>

        <section anchor='example'>
            <name>Example</name>
        </section>

        <section anchor='IANA'>
            <name>IANA Considerations</name>
            <t>
                This document contains no actions for IANA.
            </t>
        </section>

        <section anchor='security'>
            <name>Security Considerations</name>
        </section>

        <section anchor='Acknowledgements'>
            <name>Acknowledgements</name>
            <t>
                David Southgate
            </t>
            <t>
                This work has received funding from the UK Engineering and Physical
                Sciences Research Council under grant EP/R04144X/1.
            </t>
        </section>
    </middle>

    <back>
        <references>
            <name>Normative References</name>
        </references>
        
        <references>
            <name>Informative References</name>
            
            <reference  anchor="RFC8357" target='https://www.rfc-editor.org/info/rfc8357'>
                <front>
                    <title>Generalized UDP Source Port for DHCP Relay</title>
                    
                    <author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
                    <author initials='R.' surname='Hinden' fullname='R. Hinden'><organization /></author>

                    <date year='2018' month='March' />
                </front>
                <seriesInfo name='RFC' value='8357'/>
            </reference>
            <reference anchor="QUIC-TRANSPORT" target="http://www.ietf.org/internet-drafts/draft-ietf-quic-transport-20.txt">
                <front>
                    <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
                    
                    <author initials='J' surname='Iyengar' fullname='Jana Iyengar'><organization /></author>
                    <author initials='M' surname='Thomson' fullname='Martin Thomson'><organization /></author>

                    <date month='April' day='23' year='2019' />
                </front>

                <seriesInfo name='Internet-Draft' value='draft-ietf-quic-transport-20' />
            </reference>
        </references>
        
        <section anchor='ABNF'>
            <name>ABNF specification</name>
            <t>
                [todo]
            </t>
        </section>
    </back>
 </rfc>
 
